{"version":3,"sources":["../src/queryProcessor.js"],"names":["tagsModelToString","modelToString","STATS_BUCKETS","QueryProcessor","q","backendSrv","variablesHelper","capabilities","url","headers","typeResources","numericMapping","point","value","timestamp","availMapping","target","options","then","postData","start","range","from","valueOf","end","to","order","multipleMetrics","id","metricIds","resolve","caps","QUERY_POST_ENDPOINTS","raw","ids","rawQuery","timeAggFn","singleStatLiveQuery","limit","metrics","singleStatQuery","statsQuery","rawQueryLegacy","TAGS_QUERY_LANGUAGE","tagsQL","undefined","length","tags","resolveForQL","when","uri","type","rate","join","datasourceRequest","data","method","processRawResponse","response","status","all","map","encodeURIComponent","metric","replace","params","processRawResponseLegacy","refId","timeSerie","datapoints","sortedData","sort","p1","p2","_","chain","zip","slice","filter","pair","point1","point2","value_diff","time_diff","seriesAggFn","statsQueryUnmerged","buckets","stacked","percentiles","getPercentilesToQuery","stats","processStatsResponse","percentile","getPercentileValue","stat","bucket","empty","findPercentileInBucket","types","metricsPerType","processUnmergedStatsResponse","series","allMetrics","metricId","hasOwnProperty","forEach","push","perc","percentileName","idx","indexOf","substring","percObj","find","p","originalQuantile","fnBucket","avg","min","max","processSingleStatResponse","Date","now","processSingleStatLiveResponse","reduceFunc","presentValues","reduce","a","b","latestPoints","timeSeries","dp"],"mappings":";;;;;;;;;;;;;;;AAAyBA,uB,0BAAjBC,a;;;;;;;;;;;;;;;;;;;;;AAEFC,mB,GAAgB,E;;gCAETC,c;AAEX,gCAAYC,CAAZ,EAAeC,UAAf,EAA2BC,eAA3B,EAA4CC,YAA5C,EAA0DC,GAA1D,EAA+DC,OAA/D,EAAwEC,aAAxE,EAAuF;AAAA;;AACrF,eAAKN,CAAL,GAASA,CAAT;AACA,eAAKC,UAAL,GAAkBA,UAAlB;AACA,eAAKC,eAAL,GAAuBA,eAAvB;AACA,eAAKC,YAAL,GAAoBA,YAApB;AACA,eAAKC,GAAL,GAAWA,GAAX;AACA,eAAKC,OAAL,GAAeA,OAAf;AACA,eAAKC,aAAL,GAAqBA,aAArB;AACA,eAAKC,cAAL,GAAsB;AAAA,mBAAS,CAACC,MAAMC,KAAP,EAAcD,MAAME,SAApB,CAAT;AAAA,WAAtB;AACA,eAAKC,YAAL,GAAoB;AAAA,mBAAS,CAACH,MAAMC,KAAN,IAAe,IAAf,GAAsB,CAAtB,GAA0B,CAA3B,EAA8BD,MAAME,SAApC,CAAT;AAAA,WAApB;AACD;;;;8BAEGE,M,EAAQC,O,EAAS;AAAA;;AACnB,mBAAO,KAAKV,YAAL,CAAkBW,IAAlB,CAAuB,gBAAQ;AACpC,kBAAIC,WAAW;AACbC,uBAAOH,QAAQI,KAAR,CAAcC,IAAd,CAAmBC,OAAnB,EADM;AAEbC,qBAAKP,QAAQI,KAAR,CAAcI,EAAd,CAAiBF,OAAjB,EAFQ;AAGbG,uBAAO;AAHM,eAAf;AAKA,kBAAIC,kBAAkB,IAAtB;AACA,kBAAIX,OAAOY,EAAX,EAAe;AACb,oBAAMC,YAAY,MAAKvB,eAAL,CAAqBwB,OAArB,CAA6Bd,OAAOY,EAApC,EAAwCX,OAAxC,CAAlB;AACA,oBAAIc,KAAKC,oBAAT,EAA+B;AAC7B,sBAAIhB,OAAOiB,GAAX,EAAgB;AACdd,6BAASe,GAAT,GAAeL,SAAf;AACA,2BAAO,MAAKM,QAAL,CAAcnB,MAAd,EAAsBG,QAAtB,CAAP;AACD,mBAHD,MAGO,IAAIH,OAAOoB,SAAP,IAAoB,MAAxB,EAAgC;AACrC;AACA,2BAAO,MAAKC,mBAAL,CAAyBrB,MAAzB,EAAiC,EAACkB,KAAKL,SAAN,EAAiBS,OAAO,CAAxB,EAAjC,CAAP;AACD,mBAHM,MAGA,IAAItB,OAAOoB,SAAX,EAAsB;AAC3B;AACAjB,6BAASoB,OAAT,GAAmBV,SAAnB;AACA,2BAAO,MAAKW,eAAL,CAAqBxB,MAArB,EAA6BG,QAA7B,CAAP;AACD,mBAJM,MAIA;AACL;AACAA,6BAASoB,OAAT,GAAmBV,SAAnB;AACA,2BAAO,MAAKY,UAAL,CAAgBzB,MAAhB,EAAwBG,QAAxB,CAAP;AACD;AACF,iBAhBD,MAgBO;AACL,yBAAO,MAAKuB,cAAL,CAAoB1B,MAApB,EAA4BC,QAAQI,KAApC,EAA2CQ,SAA3C,CAAP;AACD;AACF,eArBD,MAqBO;AACL,oBAAIE,KAAKY,mBAAT,EAA8B;AAC5B,sBAAI3B,OAAO4B,MAAP,KAAkBC,SAAlB,IAA+B7B,OAAO4B,MAAP,CAAcE,MAAd,GAAuB,CAA1D,EAA6D;AAC3D3B,6BAAS4B,IAAT,GAAgB,MAAKzC,eAAL,CAAqB0C,YAArB,CAAkChC,OAAO4B,MAAzC,EAAiD3B,OAAjD,CAAhB;AACD,mBAFD,MAEO;AACL,2BAAO,MAAKb,CAAL,CAAO6C,IAAP,CAAY,EAAZ,CAAP;AACD;AACF,iBAND,MAMO;AACL,sBAAIjC,OAAO+B,IAAP,KAAgBF,SAAhB,IAA6B7B,OAAO+B,IAAP,CAAYD,MAAZ,GAAqB,CAAtD,EAAyD;AACvD3B,6BAAS4B,IAAT,GAAgB/C,kBAAkBgB,OAAO+B,IAAzB,EAA+B,MAAKzC,eAApC,EAAqDW,OAArD,CAAhB;AACD,mBAFD,MAEO;AACL,2BAAO,MAAKb,CAAL,CAAO6C,IAAP,CAAY,EAAZ,CAAP;AACD;AACF;AACD,oBAAIjC,OAAOiB,GAAX,EAAgB;AACd,yBAAO,MAAKE,QAAL,CAAcnB,MAAd,EAAsBG,QAAtB,CAAP;AACD,iBAFD,MAEO,IAAIH,OAAOoB,SAAP,IAAoB,MAAxB,EAAgC;AACrC;AACA,yBAAO,MAAKC,mBAAL,CAAyBrB,MAAzB,EAAiC,EAAC+B,MAAM5B,SAAS4B,IAAhB,EAAsBT,OAAO,CAA7B,EAAjC,CAAP;AACD,iBAHM,MAGA,IAAItB,OAAOoB,SAAX,EAAsB;AAC3B;AACA,yBAAO,MAAKI,eAAL,CAAqBxB,MAArB,EAA6BG,QAA7B,CAAP;AACD,iBAHM,MAGA;AACL;AACA,yBAAO,MAAKsB,UAAL,CAAgBzB,MAAhB,EAAwBG,QAAxB,CAAP;AACD;AACF;AACF,aAvDM,CAAP;AAwDD;;;mCAEQH,M,EAAQG,Q,EAAU;AAAA;;AACzB,gBAAM+B,MAAM,CACV,KAAKxC,aAAL,CAAmBM,OAAOmC,IAA1B,CADU,EACyB;AACnCnC,mBAAOoC,IAAP,GAAc,MAAd,GAAuB,KAFb,EAEoB;AAC9B,mBAHU,CAAZ;AAKA,gBAAM5C,MAAM,KAAKA,GAAL,GAAW,GAAX,GAAiB0C,IAAIG,IAAJ,CAAS,GAAT,CAA7B;;AAEA,mBAAO,KAAKhD,UAAL,CAAgBiD,iBAAhB,CAAkC;AACvC9C,mBAAKA,GADkC;AAEvC+C,oBAAMpC,QAFiC;AAGvCqC,sBAAQ,MAH+B;AAIvC/C,uBAAS,KAAKA;AAJyB,aAAlC,EAKJS,IALI,CAKC;AAAA,qBAAY,OAAKuC,kBAAL,CAAwBzC,MAAxB,EAAgC0C,SAASC,MAAT,IAAmB,GAAnB,GAAyBD,SAASH,IAAlC,GAAyC,EAAzE,CAAZ;AAAA,aALD,CAAP;AAMD;;;yCAEcvC,M,EAAQK,K,EAAOQ,S,EAAW;AAAA;;AACvC,mBAAO,KAAKzB,CAAL,CAAOwD,GAAP,CAAW/B,UAAUgC,GAAV,CAAc,kBAAU;AACxC,kBAAMX,MAAM,CACV,OAAKxC,aAAL,CAAmBM,OAAOmC,IAA1B,CADU,EACwB;AAClCW,iCAAmBC,MAAnB,EAA2BC,OAA3B,CAAmC,GAAnC,EAAwC,KAAxC,CAFU,EAEsC;AAChD,oBAHU,CAAZ;AAIA,kBAAMxD,MAAM,OAAKA,GAAL,GAAW,GAAX,GAAiB0C,IAAIG,IAAJ,CAAS,GAAT,CAA7B;;AAEA,qBAAO,OAAKhD,UAAL,CAAgBiD,iBAAhB,CAAkC;AACvC9C,qBAAKA,GADkC;AAEvCyD,wBAAQ;AACN7C,yBAAOC,MAAMC,IAAN,CAAWC,OAAX,EADD;AAENC,uBAAKH,MAAMI,EAAN,CAASF,OAAT;AAFC,iBAF+B;AAMvCiC,wBAAQ,KAN+B;AAOvC/C,yBAAS,OAAKA;AAPyB,eAAlC,EAQJS,IARI,CAQC;AAAA,uBAAY,OAAKgD,wBAAL,CAA8BlD,MAA9B,EAAsC+C,MAAtC,EAA8CL,SAASC,MAAT,IAAmB,GAAnB,GAAyBD,SAASH,IAAlC,GAAyC,EAAvF,CAAZ;AAAA,eARD,CAAP;AASD,aAhBiB,CAAX,CAAP;AAiBD;;;6CAEkBvC,M,EAAQuC,I,EAAM;AAAA;;AAC/B,mBAAOA,KAAKM,GAAL,CAAS,qBAAa;AAC3B,qBAAO;AACLM,uBAAOnD,OAAOmD,KADT;AAELnD,wBAAQoD,UAAUxC,EAFb;AAGLyC,4BAAYD,UAAUb,IAAV,CAAeM,GAAf,CAAmB7C,OAAOmC,IAAP,IAAe,cAAf,GAAgC,OAAKpC,YAArC,GAAoD,OAAKJ,cAA5E;AAHP,eAAP;AAKD,aANM,CAAP;AAOD;;;mDAEwBK,M,EAAQ+C,M,EAAQR,I,EAAM;AAC7C,gBAAIc,mBAAJ;AACA,gBAAIrD,OAAOmC,IAAP,IAAe,cAAnB,EAAmC;AACjCkB,2BAAad,KAAKM,GAAL,CAAS,KAAK9C,YAAd,CAAb;AACD,aAFD,MAEO,IAAI,CAACC,OAAOoC,IAAZ,EAAkB;AACvBiB,2BAAad,KAAKM,GAAL,CAAS,KAAKlD,cAAd,CAAb;AACD,aAFM,MAEA;AACL,kBAAI2D,aAAaf,KAAKgB,IAAL,CAAU,UAACC,EAAD,EAAKC,EAAL;AAAA,uBAAWD,GAAG1D,SAAH,GAAe2D,GAAG3D,SAA7B;AAAA,eAAV,CAAjB;AACAuD,2BAAaK,EAAEC,KAAF,CAAQL,UAAR,EACVM,GADU,CACNN,WAAWO,KAAX,CAAiB,CAAjB,CADM,EAEVC,MAFU,CAEH,gBAAQ;AACd,uBAAOC,KAAK,CAAL,EAAQ;AAAR,oBACD/D,OAAOmC,IAAP,IAAe,SAAf,IAA4B4B,KAAK,CAAL,EAAQlE,KAAR,IAAiBkE,KAAK,CAAL,EAAQlE,KADpD,CAAP,CADc,CAEqD;AACpE,eALU,EAMVgD,GANU,CAMN,gBAAQ;AACX,oBAAImB,SAASD,KAAK,CAAL,CAAb;AAAA,oBAAsBE,SAASF,KAAK,CAAL,CAA/B;AACA,oBAAIjE,YAAYmE,OAAOnE,SAAvB;AACA,oBAAIoE,aAAaD,OAAOpE,KAAP,GAAemE,OAAOnE,KAAvC;AACA,oBAAIsE,YAAYF,OAAOnE,SAAP,GAAmBkE,OAAOlE,SAA1C;AACA,oBAAIsC,OAAO,QAAQ8B,UAAR,GAAqBC,SAAhC;AACA,uBAAO,CAAC/B,IAAD,EAAOtC,SAAP,CAAP;AACD,eAbU,EAcVD,KAdU,EAAb;AAeD;AACD,mBAAO;AACLsD,qBAAOnD,OAAOmD,KADT;AAELnD,sBAAQ+C,MAFH;AAGLM,0BAAYA;AAHP,aAAP;AAKD;;;qCAEUrD,M,EAAQG,Q,EAAU;AAAA;;AAC3B,gBAAIH,OAAOoE,WAAP,KAAuB,MAA3B,EAAmC;AACjC,qBAAO,KAAKC,kBAAL,CAAwBrE,MAAxB,EAAgCG,QAAhC,CAAP;AACD;AACD,gBAAMX,MAAS,KAAKA,GAAd,SAAqB,KAAKE,aAAL,CAAmBM,OAAOmC,IAA1B,CAArB,iBAAN;AACA,mBAAOhC,SAASO,KAAhB;AACAP,qBAASmE,OAAT,GAAmBpF,aAAnB;AACAiB,qBAASoE,OAAT,GAAmBvE,OAAOoE,WAAP,KAAuB,KAA1C;AACA,gBAAMI,cAAc,KAAKC,qBAAL,CAA2BzE,OAAO0E,KAAlC,CAApB;AACA,gBAAIF,YAAY1C,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B3B,uBAASqE,WAAT,GAAuBA,YAAYnC,IAAZ,CAAiB,GAAjB,CAAvB;AACD;AACD,mBAAO,KAAKhD,UAAL,CAAgBiD,iBAAhB,CAAkC;AACvC9C,mBAAKA,GADkC;AAEvC+C,oBAAMpC,QAFiC;AAGvCqC,sBAAQ,MAH+B;AAIvC/C,uBAAS,KAAKA;AAJyB,aAAlC,EAKJS,IALI,CAKC;AAAA,qBAAY,OAAKyE,oBAAL,CAA0B3E,MAA1B,EAAkC0C,SAASC,MAAT,IAAmB,GAAnB,GAAyBD,SAASH,IAAlC,GAAyC,EAA3E,CAAZ;AAAA,aALD,CAAP;AAMD;;;+CAEoBvC,M,EAAQuC,I,EAAM;AAAA;;AACjC;AACA,mBAAOvC,OAAO0E,KAAP,CAAa7B,GAAb,CAAiB,gBAAQ;AAC9B,kBAAM+B,aAAa,OAAKC,kBAAL,CAAwBC,IAAxB,CAAnB;AACA,kBAAIF,UAAJ,EAAgB;AACd,uBAAO;AACLzB,yBAAOnD,OAAOmD,KADT;AAELnD,0BAAQ8E,IAFH;AAGLzB,8BAAYd,KAAKuB,MAAL,CAAY;AAAA,2BAAU,CAACiB,OAAOC,KAAlB;AAAA,mBAAZ,EACTnC,GADS,CACL;AAAA,2BAAU,CAAC,OAAKoC,sBAAL,CAA4BL,UAA5B,EAAwCG,MAAxC,CAAD,EAAkDA,OAAO3E,KAAzD,CAAV;AAAA,mBADK;AAHP,iBAAP;AAMD,eAPD,MAOO;AACL,uBAAO;AACL+C,yBAAOnD,OAAOmD,KADT;AAELnD,0BAAQ8E,IAFH;AAGLzB,8BAAYd,KAAKuB,MAAL,CAAY;AAAA,2BAAU,CAACiB,OAAOC,KAAlB;AAAA,mBAAZ,EAAqCnC,GAArC,CAAyC;AAAA,2BAAU,CAACkC,OAAOD,IAAP,CAAD,EAAeC,OAAO3E,KAAtB,CAAV;AAAA,mBAAzC;AAHP,iBAAP;AAKD;AACF,aAhBM,CAAP;AAiBD;;;6CAEkBJ,M,EAAQG,Q,EAAU;AAAA;;AACnC,gBAAMX,MAAS,KAAKA,GAAd,yBAAN;AACA,mBAAOW,SAASO,KAAhB;AACAP,qBAASmE,OAAT,GAAmBpF,aAAnB;AACAiB,qBAAS+E,KAAT,GAAiB,CAAClF,OAAOmC,IAAR,CAAjB;AACA,gBAAIhC,SAASoB,OAAb,EAAsB;AACpB,kBAAM4D,iBAAiB,EAAvB;AACAA,6BAAenF,OAAOmC,IAAtB,IAA8BhC,SAASoB,OAAvC;AACApB,uBAASoB,OAAT,GAAmB4D,cAAnB;AACD;AACD,gBAAMX,cAAc,KAAKC,qBAAL,CAA2BzE,OAAO0E,KAAlC,CAApB;AACA,gBAAIF,YAAY1C,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B3B,uBAASqE,WAAT,GAAuBA,YAAYnC,IAAZ,CAAiB,GAAjB,CAAvB;AACD;AACD,mBAAO,KAAKhD,UAAL,CAAgBiD,iBAAhB,CAAkC;AACvC9C,mBAAKA,GADkC;AAEvC+C,oBAAMpC,QAFiC;AAGvCqC,sBAAQ,MAH+B;AAIvC/C,uBAAS,KAAKA;AAJyB,aAAlC,EAKJS,IALI,CAKC;AAAA,qBAAY,OAAKkF,4BAAL,CAAkCpF,MAAlC,EAA0C0C,SAASC,MAAT,IAAmB,GAAnB,GAAyBD,SAASH,IAAlC,GAAyC,EAAnF,CAAZ;AAAA,aALD,CAAP;AAMD;;;uDAE4BvC,M,EAAQuC,I,EAAM;AAAA;;AACzC;AACA;AACA;AACA;AACA,gBAAM8C,SAAS,EAAf;AACA,gBAAMC,aAAa/C,KAAKvC,OAAOmC,IAAZ,CAAnB;;AANyC,uCAOhCoD,QAPgC;AAQvC,kBAAID,WAAWE,cAAX,CAA0BD,QAA1B,CAAJ,EAAyC;AACvC,oBAAMjB,UAAUgB,WAAWC,QAAX,CAAhB;AACAvF,uBAAO0E,KAAP,CAAae,OAAb,CAAqB,gBAAQ;AAC3B,sBAAMb,aAAa,OAAKC,kBAAL,CAAwBC,IAAxB,CAAnB;AACA,sBAAIF,UAAJ,EAAgB;AACdS,2BAAOK,IAAP,CAAY;AACVvC,6BAAOnD,OAAOmD,KADJ;AAEVnD,8BAAWuF,QAAX,UAAwBT,IAAxB,MAFU;AAGVzB,kCAAYiB,QAAQR,MAAR,CAAe;AAAA,+BAAU,CAACiB,OAAOC,KAAlB;AAAA,uBAAf,EACTnC,GADS,CACL;AAAA,+BAAU,CAAC,OAAKoC,sBAAL,CAA4BL,UAA5B,EAAwCG,MAAxC,CAAD,EAAkDA,OAAO3E,KAAzD,CAAV;AAAA,uBADK;AAHF,qBAAZ;AAMD,mBAPD,MAOO;AACLiF,2BAAOK,IAAP,CAAY;AACVvC,6BAAOnD,OAAOmD,KADJ;AAEVnD,8BAAWuF,QAAX,UAAwBT,IAAxB,MAFU;AAGVzB,kCAAYiB,QAAQR,MAAR,CAAe;AAAA,+BAAU,CAACiB,OAAOC,KAAlB;AAAA,uBAAf,EAAwCnC,GAAxC,CAA4C;AAAA,+BAAU,CAACkC,OAAOD,IAAP,CAAD,EAAeC,OAAO3E,KAAtB,CAAV;AAAA,uBAA5C;AAHF,qBAAZ;AAKD;AACF,iBAhBD;AAiBD;AA3BsC;;AAOzC,iBAAK,IAAImF,QAAT,IAAqBD,UAArB,EAAiC;AAAA,oBAAxBC,QAAwB;AAqBhC;AACD,mBAAOF,MAAP;AACD;;;gDAEqBX,K,EAAO;AAC3B,mBAAOA,MAAM7B,GAAN,CAAU,KAAKgC,kBAAf,EAAmCf,MAAnC,CAA0C;AAAA,qBAAQ6B,QAAQ,IAAhB;AAAA,aAA1C,CAAP;AACD;;;6CAEkBC,c,EAAgB;AACjC,gBAAMC,MAAMD,eAAeE,OAAf,CAAuB,OAAvB,CAAZ;AACA,mBAAQD,OAAO,CAAR,GAAaD,eAAeG,SAAf,CAAyB,CAAzB,EAA4BF,GAA5B,CAAb,GAAgD,IAAvD;AACD;;;iDAEsBjB,U,EAAYG,M,EAAQ;AACzC,gBAAIA,OAAOP,WAAX,EAAwB;AACtB,kBAAMwB,UAAUjB,OAAOP,WAAP,CAAmByB,IAAnB,CAAwB;AAAA,uBAAKC,EAAEC,gBAAF,IAAsBvB,UAA3B;AAAA,eAAxB,CAAhB;AACA,kBAAIoB,OAAJ,EAAa;AACX,uBAAOA,QAAQnG,KAAf;AACD;AACF;AACD,mBAAO,IAAP;AACD;;;0CAEeG,M,EAAQG,Q,EAAU;AAAA;;AAChC;AACA;AACA,gBAAIiG,iBAAJ;AACA,gBAAIpG,OAAOoB,SAAP,IAAoB,KAAxB,EAA+B;AAC7BgF,yBAAW;AAAA,uBAAUrB,OAAOsB,GAAjB;AAAA,eAAX;AACD,aAFD,MAEO,IAAIrG,OAAOoB,SAAP,IAAoB,KAAxB,EAA+B;AACpCgF,yBAAW;AAAA,uBAAUrB,OAAOuB,GAAjB;AAAA,eAAX;AACD,aAFM,MAEA,IAAItG,OAAOoB,SAAP,IAAoB,KAAxB,EAA+B;AACpCgF,yBAAW;AAAA,uBAAUrB,OAAOwB,GAAjB;AAAA,eAAX;AACD,aAV+B,CAU9B;AACF,gBAAM/G,MAAM,KAAKA,GAAL,GAAW,GAAX,GAAiB,KAAKE,aAAL,CAAmBM,OAAOmC,IAA1B,CAAjB,GAAmD,cAA/D;AACA,mBAAOhC,SAASO,KAAhB;AACAP,qBAASmE,OAAT,GAAmB,CAAnB;AACAnE,qBAASoE,OAAT,GAAmBvE,OAAOoE,WAAP,KAAuB,KAA1C;AACA,mBAAO,KAAK/E,UAAL,CAAgBiD,iBAAhB,CAAkC;AACvC9C,mBAAKA,GADkC;AAEvC+C,oBAAMpC,QAFiC;AAGvCqC,sBAAQ,MAH+B;AAIvC/C,uBAAS,KAAKA;AAJyB,aAAlC,EAKJS,IALI,CAKC;AAAA,qBAAY,OAAKsG,yBAAL,CAA+BxG,MAA/B,EAAuCoG,QAAvC,EAAiD1D,SAASC,MAAT,IAAmB,GAAnB,GAAyBD,SAASH,IAAlC,GAAyC,EAA1F,CAAZ;AAAA,aALD,CAAP;AAMD;;;oDAEyBvC,M,EAAQoG,Q,EAAU7D,I,EAAM;AAChD,mBAAOA,KAAKM,GAAL,CAAS,kBAAU;AACxB,qBAAO;AACLM,uBAAOnD,OAAOmD,KADT;AAELnD,wBAAQ,WAFH;AAGLqD,4BAAY,CAAC,CAAC+C,SAASrB,MAAT,CAAD,EAAmBA,OAAO3E,KAA1B,CAAD;AAHP,eAAP;AAKD,aANM,CAAP;AAOD;;;8CAEmBJ,M,EAAQG,Q,EAAU;AAAA;;AACpC,gBAAM+B,MAAM,CACV,KAAKxC,aAAL,CAAmBM,OAAOmC,IAA1B,CADU,EACuB;AACjCnC,mBAAOoC,IAAP,GAAc,MAAd,GAAuB,KAFb,EAEoB;AAC9B,mBAHU,CAAZ;AAKA,gBAAM5C,MAAM,KAAKA,GAAL,GAAW,GAAX,GAAiB0C,IAAIG,IAAJ,CAAS,GAAT,CAA7B;AACA;AACAlC,qBAASC,KAAT,GAAiBqG,KAAKC,GAAL,KAAa,MAA9B;AACA,mBAAO,KAAKrH,UAAL,CAAgBiD,iBAAhB,CAAkC;AACvC9C,mBAAKA,GADkC;AAEvC+C,oBAAMpC,QAFiC;AAGvCqC,sBAAQ,MAH+B;AAIvC/C,uBAAS,KAAKA;AAJyB,aAAlC,EAKJS,IALI,CAKC;AAAA,qBAAY,QAAKyG,6BAAL,CAAmC3G,MAAnC,EAA2C0C,SAASC,MAAT,IAAmB,GAAnB,GAAyBD,SAASH,IAAlC,GAAyC,EAApF,CAAZ;AAAA,aALD,CAAP;AAMD;;;wDAE6BvC,M,EAAQuC,I,EAAM;AAC1C,gBAAIqE,mBAAJ;AACA,gBAAI5G,OAAOoE,WAAP,KAAuB,KAA3B,EAAkC;AAChCwC,2BAAc;AAAA,uBAAiBC,cAAcC,MAAd,CAAqB,UAACC,CAAD,EAAGC,CAAH;AAAA,yBAASD,IAAEC,CAAX;AAAA,iBAArB,CAAjB;AAAA,eAAd;AACD,aAFD,MAEO;AACLJ,2BAAc;AAAA,uBAAiBC,cAAcC,MAAd,CAAqB,UAACC,CAAD,EAAGC,CAAH;AAAA,yBAASD,IAAEC,CAAX;AAAA,iBAArB,IAAqCH,cAAc/E,MAApE;AAAA,eAAd;AACD;AACD,gBAAIuB,mBAAJ;AACA,gBAAM4D,eAAe1E,KAAKuB,MAAL,CAAY;AAAA,qBAAcoD,WAAW3E,IAAX,CAAgBT,MAAhB,GAAyB,CAAvC;AAAA,aAAZ,EAChBe,GADgB,CACZ;AAAA,qBAAcqE,WAAW3E,IAAX,CAAgB,CAAhB,CAAd;AAAA,aADY,CAArB;AAEA,gBAAI0E,aAAanF,MAAb,KAAwB,CAA5B,EAA+B;AAC7BuB,2BAAa,EAAb;AACD,aAFD,MAEO;AACLA,2BAAa,CAAC,CAACuD,WAAWK,aAAapE,GAAb,CAAiB;AAAA,uBAAMsE,GAAGtH,KAAT;AAAA,eAAjB,CAAX,CAAD,EAA+CoH,aAAa,CAAb,EAAgBnH,SAA/D,CAAD,CAAb;AACD;AACD,mBAAO,CAAC;AACNqD,qBAAOnD,OAAOmD,KADR;AAENnD,sBAAQ,WAFF;AAGNqD,0BAAYA;AAHN,aAAD,CAAP;AAKD","file":"queryProcessor.js","sourcesContent":["import {modelToString as tagsModelToString} from './tagsKVPairsController';\n\nconst STATS_BUCKETS = 60;\n\nexport class QueryProcessor {\n\n  constructor(q, backendSrv, variablesHelper, capabilities, url, headers, typeResources) {\n    this.q = q;\n    this.backendSrv = backendSrv;\n    this.variablesHelper = variablesHelper;\n    this.capabilities = capabilities;\n    this.url = url;\n    this.headers = headers;\n    this.typeResources = typeResources;\n    this.numericMapping = point => [point.value, point.timestamp];\n    this.availMapping = point => [point.value == 'up' ? 1 : 0, point.timestamp];\n  }\n\n  run(target, options) {\n    return this.capabilities.then(caps => {\n      let postData = {\n        start: options.range.from.valueOf(),\n        end: options.range.to.valueOf(),\n        order: 'ASC'\n      };\n      let multipleMetrics = true;\n      if (target.id) {\n        const metricIds = this.variablesHelper.resolve(target.id, options);\n        if (caps.QUERY_POST_ENDPOINTS) {\n          if (target.raw) {\n            postData.ids = metricIds;\n            return this.rawQuery(target, postData);\n          } else if (target.timeAggFn == 'live') {\n            // Need to change postData\n            return this.singleStatLiveQuery(target, {ids: metricIds, limit: 1});\n          } else if (target.timeAggFn) {\n            // Query single stat\n            postData.metrics = metricIds;\n            return this.singleStatQuery(target, postData);\n          } else {\n            // Query stats for chart\n            postData.metrics = metricIds;\n            return this.statsQuery(target, postData);\n          }\n        } else {\n          return this.rawQueryLegacy(target, options.range, metricIds);\n        }\n      } else {\n        if (caps.TAGS_QUERY_LANGUAGE) {\n          if (target.tagsQL !== undefined && target.tagsQL.length > 0) {\n            postData.tags = this.variablesHelper.resolveForQL(target.tagsQL, options);\n          } else {\n            return this.q.when([]);\n          }\n        } else {\n          if (target.tags !== undefined && target.tags.length > 0) {\n            postData.tags = tagsModelToString(target.tags, this.variablesHelper, options);\n          } else {\n            return this.q.when([]);\n          }\n        }\n        if (target.raw) {\n          return this.rawQuery(target, postData);\n        } else if (target.timeAggFn == 'live') {\n          // Need to change postData\n          return this.singleStatLiveQuery(target, {tags: postData.tags, limit: 1});\n        } else if (target.timeAggFn) {\n          // Query single stat\n          return this.singleStatQuery(target, postData);\n        } else {\n          // Query stats for chart\n          return this.statsQuery(target, postData);\n        }\n      }\n    });\n  }\n\n  rawQuery(target, postData) {\n    const uri = [\n      this.typeResources[target.type],   // gauges or counters\n      target.rate ? 'rate' : 'raw', // raw or rate\n      'query'\n    ];\n    const url = this.url + '/' + uri.join('/');\n\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processRawResponse(target, response.status == 200 ? response.data : []));\n  }\n\n  rawQueryLegacy(target, range, metricIds) {\n    return this.q.all(metricIds.map(metric => {\n      const uri = [\n        this.typeResources[target.type],  // gauges, counters or availability\n        encodeURIComponent(metric).replace('+', '%20'), // metric name\n        'data'];\n      const url = this.url + '/' + uri.join('/');\n\n      return this.backendSrv.datasourceRequest({\n        url: url,\n        params: {\n          start: range.from.valueOf(),\n          end: range.to.valueOf()\n        },\n        method: 'GET',\n        headers: this.headers\n      }).then(response => this.processRawResponseLegacy(target, metric, response.status == 200 ? response.data : []));\n    }));\n  }\n\n  processRawResponse(target, data) {\n    return data.map(timeSerie => {\n      return {\n        refId: target.refId,\n        target: timeSerie.id,\n        datapoints: timeSerie.data.map(target.type == 'availability' ? this.availMapping : this.numericMapping)\n      };\n    });\n  }\n\n  processRawResponseLegacy(target, metric, data) {\n    let datapoints;\n    if (target.type == 'availability') {\n      datapoints = data.map(this.availMapping);\n    } else if (!target.rate) {\n      datapoints = data.map(this.numericMapping);\n    } else {\n      let sortedData = data.sort((p1, p2)=> p1.timestamp - p2.timestamp);\n      datapoints = _.chain(sortedData)\n        .zip(sortedData.slice(1))\n        .filter(pair => {\n          return pair[1] // Exclude the last pair\n            && (target.type != 'counter' || pair[0].value <= pair[1].value); // Exclude counter resets\n        })\n        .map(pair => {\n          let point1 = pair[0], point2 = pair[1];\n          let timestamp = point2.timestamp;\n          let value_diff = point2.value - point1.value;\n          let time_diff = point2.timestamp - point1.timestamp;\n          let rate = 60000 * value_diff / time_diff;\n          return [rate, timestamp];\n        })\n        .value();\n    }\n    return {\n      refId: target.refId,\n      target: metric,\n      datapoints: datapoints\n    };\n  }\n\n  statsQuery(target, postData) {\n    if (target.seriesAggFn === 'none') {\n      return this.statsQueryUnmerged(target, postData);\n    }\n    const url = `${this.url}/${this.typeResources[target.type]}/stats/query`;\n    delete postData.order;\n    postData.buckets = STATS_BUCKETS;\n    postData.stacked = target.seriesAggFn === 'sum';\n    const percentiles = this.getPercentilesToQuery(target.stats);\n    if (percentiles.length > 0) {\n      postData.percentiles = percentiles.join(',');\n    }\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processStatsResponse(target, response.status == 200 ? response.data : []));\n  }\n\n  processStatsResponse(target, data) {\n    // Response example: [{start:1234, end:5678, avg:100.0, min:90.0, max:110.0, (...), percentiles:[{originalQuantile:'90', value: 105.0, (...)}]}]\n    return target.stats.map(stat => {\n      const percentile = this.getPercentileValue(stat);\n      if (percentile) {\n        return {\n          refId: target.refId,\n          target: stat,\n          datapoints: data.filter(bucket => !bucket.empty)\n            .map(bucket => [this.findPercentileInBucket(percentile, bucket), bucket.start])\n        };\n      } else {\n        return {\n          refId: target.refId,\n          target: stat,\n          datapoints: data.filter(bucket => !bucket.empty).map(bucket => [bucket[stat], bucket.start])\n        };\n      }\n    });\n  }\n\n  statsQueryUnmerged(target, postData) {\n    const url = `${this.url}/metrics/stats/query`;\n    delete postData.order;\n    postData.buckets = STATS_BUCKETS;\n    postData.types = [target.type];\n    if (postData.metrics) {\n      const metricsPerType = {};\n      metricsPerType[target.type] = postData.metrics;\n      postData.metrics = metricsPerType;\n    }\n    const percentiles = this.getPercentilesToQuery(target.stats);\n    if (percentiles.length > 0) {\n      postData.percentiles = percentiles.join(',');\n    }\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processUnmergedStatsResponse(target, response.status == 200 ? response.data : []));\n  }\n\n  processUnmergedStatsResponse(target, data) {\n    // Response example:\n    // {\"gauge\": {\"my_metric\": [\n    //    {start:1234, end:5678, avg:100.0, min:90.0, max:110.0, (...), percentiles:[{originalQuantile:'90', value: 105.0, (...)}]}\n    // ]}}\n    const series = [];\n    const allMetrics = data[target.type];\n    for (let metricId in allMetrics) {\n      if (allMetrics.hasOwnProperty(metricId)) {\n        const buckets = allMetrics[metricId];\n        target.stats.forEach(stat => {\n          const percentile = this.getPercentileValue(stat);\n          if (percentile) {\n            series.push({\n              refId: target.refId,\n              target: `${metricId} [${stat}]`,\n              datapoints: buckets.filter(bucket => !bucket.empty)\n                .map(bucket => [this.findPercentileInBucket(percentile, bucket), bucket.start])\n            });\n          } else {\n            series.push({\n              refId: target.refId,\n              target: `${metricId} [${stat}]`,\n              datapoints: buckets.filter(bucket => !bucket.empty).map(bucket => [bucket[stat], bucket.start])\n            });\n          }\n        });\n      }\n    }\n    return series;\n  }\n\n  getPercentilesToQuery(stats) {\n    return stats.map(this.getPercentileValue).filter(perc => perc != null);\n  }\n\n  getPercentileValue(percentileName) {\n    const idx = percentileName.indexOf(' %ile');\n    return (idx >= 0) ? percentileName.substring(0, idx) : null;\n  }\n\n  findPercentileInBucket(percentile, bucket) {\n    if (bucket.percentiles) {\n      const percObj = bucket.percentiles.find(p => p.originalQuantile == percentile);\n      if (percObj) {\n        return percObj.value;\n      }\n    }\n    return null;\n  }\n\n  singleStatQuery(target, postData) {\n    // Query for singlestat => we just ask for a single bucket\n    // But because of that we need to override Grafana behaviour, and manage ourselves the min/max/avg/etc. selection\n    let fnBucket;\n    if (target.timeAggFn == 'avg') {\n      fnBucket = bucket => bucket.avg;\n    } else if (target.timeAggFn == 'min') {\n      fnBucket = bucket => bucket.min;\n    } else if (target.timeAggFn == 'max') {\n      fnBucket = bucket => bucket.max;\n    } // no else case. \"live\" case was handled before\n    const url = this.url + '/' + this.typeResources[target.type] + '/stats/query';\n    delete postData.order;\n    postData.buckets = 1;\n    postData.stacked = target.seriesAggFn === 'sum';\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processSingleStatResponse(target, fnBucket, response.status == 200 ? response.data : []));\n  }\n\n  processSingleStatResponse(target, fnBucket, data) {\n    return data.map(bucket => {\n      return {\n        refId: target.refId,\n        target: \"Aggregate\",\n        datapoints: [[fnBucket(bucket), bucket.start]]\n      };\n    });\n  }\n\n  singleStatLiveQuery(target, postData) {\n    const uri = [\n      this.typeResources[target.type], // gauges, counters or availability\n      target.rate ? 'rate' : 'raw', // raw or rate\n      'query'\n    ];\n    const url = this.url + '/' + uri.join('/');\n    // Set start to now - 5m\n    postData.start = Date.now() - 300000;\n    return this.backendSrv.datasourceRequest({\n      url: url,\n      data: postData,\n      method: 'POST',\n      headers: this.headers\n    }).then(response => this.processSingleStatLiveResponse(target, response.status == 200 ? response.data : []));\n  }\n\n  processSingleStatLiveResponse(target, data) {\n    let reduceFunc;\n    if (target.seriesAggFn === 'sum') {\n      reduceFunc = (presentValues => presentValues.reduce((a,b) => a+b));\n    } else {\n      reduceFunc = (presentValues => presentValues.reduce((a,b) => a+b) / presentValues.length);\n    }\n    let datapoints;\n    const latestPoints = data.filter(timeSeries => timeSeries.data.length > 0)\n        .map(timeSeries => timeSeries.data[0]);\n    if (latestPoints.length === 0) {\n      datapoints = [];\n    } else {\n      datapoints = [[reduceFunc(latestPoints.map(dp => dp.value)), latestPoints[0].timestamp]];\n    }\n    return [{\n      refId: target.refId,\n      target: \"Aggregate\",\n      datapoints: datapoints\n    }];\n  }\n}\n"]}